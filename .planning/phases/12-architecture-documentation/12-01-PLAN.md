---
phase: 12-architecture-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/quantization/04-architecture.md
  - docs/images/resnet8_qdq_architecture.png
  - docs/images/resnet8_qdq_architecture.svg
  - scripts/annotate_qdq_graph.py
autonomous: true

must_haves:
  truths:
    - "Data flow diagram shows complete path through quantized ResNet8 (FP32 input → QuantizeLinear → INT8 layers → DequantizeLinear → FP32 output)"
    - "Scale and zero-point parameter locations documented showing which initializers store them and where they appear in Q/DQ node inputs"
    - "QDQ format architecture explained - how QuantizeLinear/DequantizeLinear pairs enable INT8 computation through standard operators"
  artifacts:
    - path: "docs/quantization/04-architecture.md"
      provides: "Main architecture documentation"
      contains: ["QDQ Format", "Data Flow", "Scale", "Zero-Point", "Initializer"]
    - path: "docs/images/resnet8_qdq_architecture.png"
      provides: "Network visualization showing Q/DQ placement"
    - path: "scripts/annotate_qdq_graph.py"
      provides: "Script for generating annotated architecture diagrams"
  key_links:
    - from: "docs/quantization/04-architecture.md"
      to: "docs/quantization/01-boundary-operations.md"
      via: "cross-reference link"
      pattern: "01-boundary-operations"
    - from: "docs/quantization/04-architecture.md"
      to: "docs/images/resnet8_qdq_architecture.png"
      via: "image embed"
      pattern: "resnet8_qdq_architecture"
---

<objective>
Document the QDQ format architecture of quantized ResNet8 with annotated network visualization showing data flow and scale/zero-point parameter locations.

Purpose: Enable hardware implementers to understand how quantization is implemented in actual ONNX models (QDQ format with Q/DQ pairs around standard operators, not QLinear operators).

Output:
- Architecture documentation explaining QDQ format data flow
- Annotated network visualization showing Q/DQ placement and data types
- Script for generating annotated architecture diagrams
</objective>

<execution_context>
@/home/impactaky/shelffiles/config/claude/get-shit-done/workflows/execute-plan.md
@/home/impactaky/shelffiles/config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-architecture-documentation/12-RESEARCH.md

# Prior phase context (QDQ understanding, visualization patterns)
@.planning/phases/09-operation-extraction-scripts/09-01-SUMMARY.md
@.planning/phases/10-boundary-operations-documentation/10-01-SUMMARY.md
@.planning/phases/11-core-operations-documentation/11-01-SUMMARY.md

# Existing documentation to cross-reference
@docs/quantization/01-boundary-operations.md

# Existing scripts to adapt
@scripts/extract_operations.py
@scripts/visualize_graph.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create annotated QDQ graph visualization script</name>
  <files>scripts/annotate_qdq_graph.py</files>
  <action>
Create a Python script that generates annotated architecture diagrams showing:
1. QDQ node placement (QuantizeLinear/DequantizeLinear positions)
2. Data type annotations at each stage (FP32 → INT8 → FP32)
3. Scale/zero-point parameter names from initializers

Adapt from existing scripts/visualize_graph.py pattern. Key additions:
- Parse ONNX graph to identify Q/DQ nodes
- Build lookup of which initializers provide scales/zero-points
- Use pydot to generate graph with custom node labels showing data types
- Add edge annotations for data types between nodes

Output: PNG and SVG files in docs/images/

Use patterns from Phase 9:
- onnx.helper for attribute extraction
- initializer lookup dict pattern
- subprocess.run() for dot command (not deprecated pydot.write_png)

Include argparse with --model, --output-dir arguments.
  </action>
  <verify>
Run: `python scripts/annotate_qdq_graph.py --model models/resnet8_int8.onnx --output-dir docs/images/`
Verify: PNG file created at docs/images/resnet8_qdq_architecture.png
  </verify>
  <done>
Script creates annotated diagram showing Q/DQ node placement with data type labels (FP32/INT8) and scale/zero-point parameter names.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create QDQ architecture documentation</name>
  <files>docs/quantization/04-architecture.md</files>
  <action>
Create comprehensive architecture documentation covering:

## 1. QDQ Format Overview
- Explain QDQ format vs QLinear operators (QDQ is what actual models use)
- Show pattern: Input → QuantizeLinear → DequantizeLinear → Conv(FP32) → QuantizeLinear → DequantizeLinear → Output
- Explain why ONNX Runtime uses QDQ format (better debugging, easier optimization, wider hardware support)
- Cross-reference to Phases 10-11 for operation-level details

## 2. ResNet8 Quantized Data Flow
- Full path: FP32 input → QuantizeLinear → INT8 layers → DequantizeLinear → FP32 output
- List all Q/DQ nodes from model extraction (use extract_operations.py output)
- Show which layers operate on INT8 data vs FP32 data

## 3. Scale and Zero-Point Parameter Locations
- Explain initializers vs runtime inputs (scales/zero-points are typically initializers)
- Document naming convention in ResNet8 ONNX graph
- Show example: x_scale stored in initializer "conv1_x_scale", referenced by QuantizeLinear input[1]
- Table of all scale/zero-point initializers with their locations

## 4. Network Visualization
- Embed the generated PNG/SVG from Task 1
- Annotate key sections (input quantization, conv blocks, residual adds, output dequantization)
- Explain data type transitions at each stage

Follow established patterns:
- GitHub MathJax syntax where formulas needed (escape underscores)
- Cross-reference to existing docs instead of duplicating
- Use exact ONNX terminology for consistency
  </action>
  <verify>
Check file exists: `test -f docs/quantization/04-architecture.md`
Check cross-references: `grep -c "01-boundary-operations" docs/quantization/04-architecture.md` (should be >= 1)
Check image embed: `grep -c "resnet8_qdq_architecture" docs/quantization/04-architecture.md` (should be >= 1)
Check QDQ content: `grep -c "QuantizeLinear" docs/quantization/04-architecture.md` (should be >= 5)
  </verify>
  <done>
Architecture documentation explains QDQ format, shows full data flow through ResNet8, documents scale/zero-point locations in initializers, and embeds network visualization.
  </done>
</task>

</tasks>

<verification>
1. `python scripts/annotate_qdq_graph.py --model models/resnet8_int8.onnx --output-dir docs/images/` succeeds
2. `ls docs/images/resnet8_qdq_architecture.png` confirms PNG exists
3. `ls docs/images/resnet8_qdq_architecture.svg` confirms SVG exists
4. `docs/quantization/04-architecture.md` contains QDQ format explanation
5. Documentation cross-references boundary operations (01-boundary-operations.md)
6. Network visualization embedded in documentation
</verification>

<success_criteria>
- Annotated network visualization shows Q/DQ placement with data types (FP32/INT8)
- Architecture documentation explains QDQ format as the actual model implementation
- Scale and zero-point parameter locations documented (which initializers, which inputs)
- Data flow path clearly shows FP32 input → INT8 computation → FP32 output
- Cross-references to existing operation documentation (avoid duplication)
</success_criteria>

<output>
After completion, create `.planning/phases/12-architecture-documentation/12-01-SUMMARY.md`
</output>
