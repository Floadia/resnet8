---
phase: 09-operation-extraction-scripts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/extract_operations.py
  - scripts/visualize_graph.py
autonomous: true
user_setup:
  - service: graphviz
    why: "Graph rendering for visualization"
    install:
      - os: linux
        command: "sudo apt-get install graphviz"
      - os: macos
        command: "brew install graphviz"

must_haves:
  truths:
    - "Running extract_operations.py on resnet8_int8.onnx produces valid JSON file"
    - "JSON contains all QLinearConv, QLinearMatMul, QuantizeLinear, DequantizeLinear nodes"
    - "JSON includes scale and zero-point numeric values (not just names)"
    - "Running visualize_graph.py on resnet8_int8.onnx produces PNG and SVG files"
    - "PNG/SVG show node types and data flow from input to output"
  artifacts:
    - path: "scripts/extract_operations.py"
      provides: "QLinear node extraction to JSON"
      exports: ["main"]
    - path: "scripts/visualize_graph.py"
      provides: "ONNX graph visualization"
      exports: ["main"]
  key_links:
    - from: "scripts/extract_operations.py"
      to: "models/resnet8_int8.onnx"
      via: "onnx.load()"
      pattern: "onnx\\.load"
    - from: "scripts/visualize_graph.py"
      to: "graphviz dot command"
      via: "subprocess.run"
      pattern: 'subprocess\\.run.*dot.*-T(png|svg)'
---

<objective>
Create two scripts: (1) extract_operations.py extracts all quantized operation details from ONNX models to structured JSON, (2) visualize_graph.py generates PNG/SVG graph diagrams of ONNX models.

Purpose: These tools enable data-driven documentation in subsequent phases (10-13) by providing structured quantization parameters and visual model representations.

Output:
- scripts/extract_operations.py - CLI tool outputting JSON with QLinear nodes, scales, zero-points
- scripts/visualize_graph.py - CLI tool outputting PNG/SVG visualizations
</objective>

<execution_context>
@/home/impactaky/shelffiles/config/claude/get-shit-done/workflows/execute-plan.md
@/home/impactaky/shelffiles/config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-operation-extraction-scripts/09-RESEARCH.md

# Existing script patterns to follow
@scripts/quantize_onnx.py
@scripts/evaluate.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create extract_operations.py</name>
  <files>scripts/extract_operations.py</files>
  <action>
Create scripts/extract_operations.py that extracts all quantized operations from ONNX models to JSON.

Follow existing project patterns from quantize_onnx.py:
- argparse CLI with --model and --output arguments
- Docstring explaining purpose
- Type hints throughout

Implementation requirements:
1. Load ONNX model using onnx.load()
2. Build initializer lookup dict mapping names to numpy arrays (use onnx.numpy_helper.to_array())
3. Iterate graph.node, filter by op_type in ["QLinearConv", "QLinearMatMul", "QuantizeLinear", "DequantizeLinear"]
4. For each node, extract:
   - name, op_type, inputs (list), outputs (list)
   - attributes using onnx.helper.get_attribute_value() (NOT direct .f/.i/.s access)
   - scales and zero_points by matching input names to initializers
5. Convert numpy types to Python types before JSON serialization:
   - Scalars: float(value) or int(value) based on dtype.kind
   - Arrays: value.tolist()
6. Output JSON structure:
   ```json
   {
     "model_path": "...",
     "opset_version": N,
     "operations": [...],
     "summary": {
       "total_nodes": N,
       "qlinear_nodes": N,
       "op_type_counts": {...}
     }
   }
   ```

Default arguments:
- --model: models/resnet8_int8.onnx
- --output: models/resnet8_int8_operations.json

Print summary to stdout: total nodes, quantized nodes, counts by op_type.
  </action>
  <verify>
Run: `python scripts/extract_operations.py --model models/resnet8_int8.onnx --output /tmp/test_ops.json`
Verify:
- Script exits 0
- JSON file created at /tmp/test_ops.json
- JSON is valid (python -m json.tool /tmp/test_ops.json)
- JSON contains "operations" array with multiple entries
- At least one operation has "scales" dict with numeric values (not strings)
  </verify>
  <done>
- extract_operations.py exists and is executable
- Running on resnet8_int8.onnx produces valid JSON
- JSON contains all four op_types (QLinearConv, QuantizeLinear, DequantizeLinear, and QLinearMatMul if present)
- Scales and zero-points are numeric values, not initializer name strings
  </done>
</task>

<task type="auto">
  <name>Task 2: Create visualize_graph.py</name>
  <files>scripts/visualize_graph.py</files>
  <action>
Create scripts/visualize_graph.py that generates PNG/SVG visualizations of ONNX models.

Follow existing project patterns from quantize_onnx.py:
- argparse CLI with --model and --output-dir arguments
- Docstring explaining purpose
- Type hints throughout

Implementation requirements:
1. Check for graphviz installation at startup:
   ```python
   result = subprocess.run(["dot", "-V"], capture_output=True)
   if result.returncode != 0:
       print("Error: Graphviz not installed. Install with:")
       print("  Ubuntu/Debian: sudo apt-get install graphviz")
       print("  macOS: brew install graphviz")
       sys.exit(1)
   ```
2. Load ONNX model using onnx.load()
3. Generate pydot graph using onnx.tools.net_drawer.GetPydotGraph():
   - name: Use model.graph.name or derive from model filename
   - rankdir="TB" (top-to-bottom layout for CNN architecture)
   - embed_docstring=True (include operator tooltips)
4. Write .dot file using pydot_graph.write_dot()
5. Convert to PNG and SVG using subprocess.run() with check=True:
   ```python
   subprocess.run(["dot", "-Tpng", dot_path, "-o", png_path], check=True)
   subprocess.run(["dot", "-Tsvg", dot_path, "-o", svg_path], check=True)
   ```
6. Print output paths to stdout

Default arguments:
- --model: models/resnet8_int8.onnx
- --output-dir: models/ (outputs: models/resnet8_int8.dot, .png, .svg)

Handle pydot import error gracefully with install hint: `pip install pydot`
  </action>
  <verify>
Run: `python scripts/visualize_graph.py --model models/resnet8_int8.onnx --output-dir /tmp/`
Verify:
- Script exits 0
- Three files created: /tmp/resnet8_int8.dot, /tmp/resnet8_int8.png, /tmp/resnet8_int8.svg
- PNG file is valid image (file /tmp/resnet8_int8.png shows "PNG image data")
- SVG file contains svg tag (grep -q '<svg' /tmp/resnet8_int8.svg)
  </verify>
  <done>
- visualize_graph.py exists and is executable
- Running on resnet8_int8.onnx produces .dot, .png, .svg files
- PNG is valid image file
- SVG is valid SVG file
- Script provides helpful error if graphviz not installed
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Verify extraction script captures all quantized ops:
   ```bash
   python scripts/extract_operations.py
   # Check output JSON has QuantizeLinear AND DequantizeLinear (boundary ops)
   # Check output JSON has QLinearConv (core ops)
   ```

2. Verify visualization shows clear graph structure:
   ```bash
   python scripts/visualize_graph.py
   # Visual inspection: PNG should show input -> layers -> output flow
   ```

3. Verify both scripts follow project conventions:
   - Shebang line (#!/usr/bin/env python3)
   - Module docstring
   - Type hints
   - argparse with defaults matching project paths
</verification>

<success_criteria>
- [ ] extract_operations.py creates valid JSON with all four quantized op types
- [ ] JSON contains numeric scale/zero-point values (not string references)
- [ ] visualize_graph.py creates .dot, .png, .svg outputs
- [ ] Visualizations show operator types and data flow
- [ ] Both scripts have argparse CLI consistent with existing project scripts
- [ ] Both scripts run without errors on resnet8_int8.onnx
</success_criteria>

<output>
After completion, create `.planning/phases/09-operation-extraction-scripts/09-01-SUMMARY.md`
</output>
