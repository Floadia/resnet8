---
phase: 14-notebook-foundation
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - playground/utils/layer_inspector.py
  - playground/quantization.py
autonomous: false

must_haves:
  truths:
    - "User can select layer/operation from dropdown populated with model structure"
    - "Dropdown updates immediately when selection changes (no button needed)"
    - "Layer list shows full paths (e.g., layer1.conv1.weight)"
  artifacts:
    - path: "playground/utils/layer_inspector.py"
      provides: "Layer name extraction for ONNX and PyTorch"
      contains: "def get_layer_names"
    - path: "playground/quantization.py"
      provides: "Complete notebook with layer selection"
      contains: "mo.ui.dropdown"
  key_links:
    - from: "playground/quantization.py"
      to: "playground/utils/layer_inspector.py"
      via: "import statement"
      pattern: "from.*layer_inspector import"
    - from: "playground/quantization.py dropdown"
      to: "layer data display"
      via: "reactive cell dependency"
      pattern: "layer_selector\\.value"
---

<objective>
Add layer inspection utilities and complete the notebook UI with layer selection dropdown that populates from loaded model structure.

Purpose: Enable users to explore model structure by selecting layers from a dropdown. The dropdown populates from actual model layer names (ONNX nodes/initializers, PyTorch named_modules) and updates reactively when selection changes.

Output:
- `playground/utils/layer_inspector.py` - Layer name extraction for both frameworks
- Updated `playground/quantization.py` - Complete notebook with layer selection UI
</objective>

<execution_context>
@/home/impactaky/shelffiles/config/claude/get-shit-done/workflows/execute-plan.md
@/home/impactaky/shelffiles/config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-notebook-foundation/14-CONTEXT.md
@.planning/phases/14-notebook-foundation/14-RESEARCH.md
@.planning/phases/14-notebook-foundation/14-01-SUMMARY.md
@playground/utils/model_loader.py
@playground/quantization.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create layer inspection utilities</name>
  <files>
    playground/utils/layer_inspector.py
    playground/utils/__init__.py
  </files>
  <action>
Create playground/utils/layer_inspector.py with layer extraction functions:

1. `get_onnx_layer_names(model)`:
   - Takes onnx.ModelProto
   - Extracts node names from `model.graph.node` (operations)
   - Extracts initializer names from `model.graph.initializer` (weights/biases)
   - Filters out empty names
   - Returns sorted, deduplicated list of all layer names
   - Per RESEARCH.md: combine both node_names and init_names for complete list

2. `get_pytorch_layer_names(model)`:
   - Takes PyTorch model (nn.Module)
   - Uses `model.named_modules()` to get hierarchical paths
   - Filters out root module (empty name) per pitfall #6 in RESEARCH.md
   - Returns list of layer names like `layer1.conv1`, `layer2.0.bn1`

3. `get_all_layer_names(models_dict)`:
   - Takes dict from load_model_variants (keys: 'onnx_float', 'pytorch_float', etc.)
   - Extracts layer names from first available model of each type
   - Prioritizes ONNX float model if available, else PyTorch
   - Returns dict: {'layer_names': [...], 'source': 'onnx' or 'pytorch'}

4. `get_layer_type(model, layer_name)`:
   - For ONNX: find node with matching name, return op_type
   - For PyTorch: find module with matching name, return class name
   - Returns string like "Conv", "BatchNormalization", "Linear"

Update playground/utils/__init__.py to export layer_inspector functions.

Imports:
```python
import onnx
import torch
from typing import Dict, List, Optional, Any
```
  </action>
  <verify>
Run: `cd /var/tmp/vibe-kanban/worktrees/8ac8-gsd-discuss-phas/resnet8 && python -c "from playground.utils.layer_inspector import get_onnx_layer_names, get_pytorch_layer_names; print('Import successful')"`
Run: `grep -c "named_modules" playground/utils/layer_inspector.py` confirms PyTorch pattern used
  </verify>
  <done>
- playground/utils/layer_inspector.py exists with all 4 functions
- Functions handle both ONNX and PyTorch models
- ONNX extraction includes both nodes and initializers
- PyTorch extraction filters out root module (empty name)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add layer selection dropdown to notebook</name>
  <files>
    playground/quantization.py
  </files>
  <action>
Update playground/quantization.py to add layer selection UI:

1. Add import for layer_inspector:
   ```python
   from playground.utils.layer_inspector import get_all_layer_names, get_layer_type
   ```

2. Add cell to extract layer names after models load:
   - Check if models dict exists and has loaded models
   - Call `get_all_layer_names(models)` to get layer list
   - Store result for dropdown population

3. Add layer selector dropdown cell:
   - Create `mo.ui.dropdown()` with:
     - `options=layer_names if layer_names else ["Select a layer..."]` (per pitfall #5)
     - `value=None` (no initial selection)
     - `allow_select_none=True`
     - `label="Layer to analyze"`
   - Return dropdown to display it

4. Add layer info display cell (reactive to dropdown):
   - Access `layer_selector.value` to trigger reactivity
   - If no selection: show "Select a layer..." placeholder with empty area
   - If layer selected: show layer name and type
   - Per CONTEXT.md: "Immediate on selection (no button)"

5. Per CONTEXT.md initial state decisions:
   - After load, no layer selected: dropdown shows "Select a layer..." with empty plots area
   - On new model load: reset dropdown to no selection

Follow Marimo reactivity patterns:
- Cells that reference `layer_selector.value` auto-run when selection changes
- Don't mutate state, create new values
  </action>
  <verify>
Run: `grep "mo.ui.dropdown" playground/quantization.py` confirms dropdown widget
Run: `grep "layer_selector.value" playground/quantization.py` confirms reactive access pattern
Run: `python -c "exec(open('playground/quantization.py').read())"` - syntax check passes
  </verify>
  <done>
- Notebook has layer selection dropdown populated from model structure
- Dropdown shows "Select a layer..." placeholder before selection
- Selecting a layer triggers reactive update to display cell
- Layer names show full paths (e.g., layer1.conv1.weight)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Marimo notebook with:
- File picker for model folder selection
- Cached model loading with spinner
- Model summary display (name, format, layer count)
- Layer selection dropdown populated from model structure
- Reactive updates on layer selection
  </what-built>
  <how-to-verify>
1. Ensure ONNX models exist (run conversion if needed):
   ```bash
   cd /var/tmp/vibe-kanban/worktrees/8ac8-gsd-discuss-phas/resnet8
   # If models/*.onnx don't exist, run:
   # python scripts/convert.py
   # python scripts/quantize_onnx.py
   ```

2. Launch notebook:
   ```bash
   marimo edit playground/quantization.py
   ```

3. Verify initial state:
   - Instructions text visible: "Select a model folder to begin"
   - File picker widget present

4. Select models/ folder via file picker:
   - Spinner should appear during loading
   - Model summary should appear showing loaded variants
   - Summary shows: name, format, layer count

5. Verify layer dropdown:
   - Dropdown populated with layer names from model
   - Initial state: "Select a layer..." or similar placeholder
   - Layer names show full paths (e.g., containing dots like `layer1.conv1`)

6. Select a layer:
   - Selection should trigger immediate update (no button click needed)
   - Layer info should display (at minimum: layer name and type)

7. Memory test (optional but recommended):
   - Re-select the same folder multiple times
   - Check that memory usage stays stable (caching works)
   - No errors about loading repeatedly
  </how-to-verify>
  <resume-signal>Type "approved" if all verification steps pass, or describe specific issues encountered</resume-signal>
</task>

</tasks>

<verification>
1. Launch: `marimo edit playground/quantization.py`
2. Verify file picker appears
3. Select models/ folder
4. Verify spinner during load, then summary appears
5. Verify layer dropdown populated with layer names
6. Select a layer, verify reactive update occurs
7. Verify layer names include full paths (dots in names)
</verification>

<success_criteria>
- File picker allows folder selection
- Model loading shows spinner, then summary
- Layer dropdown populated from actual model structure
- Layer names show full paths (e.g., layer1.conv1.weight)
- Selecting layer triggers immediate reactive update
- No button click needed for layer selection to take effect
</success_criteria>

<output>
After completion, create `.planning/phases/14-notebook-foundation/14-02-SUMMARY.md`
</output>
