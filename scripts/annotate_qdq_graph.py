#!/usr/bin/env python3
"""Generate annotated QDQ architecture diagrams showing data flow and Q/DQ placement.

Creates visualizations from operation JSON files (generated by extract_operations.py)
showing QuantizeLinear/DequantizeLinear node placement, data type transitions
(FP32 → INT8 → FP32), and scale/zero-point parameter locations.

This script works with operation JSON files rather than requiring ONNX libraries,
making it more portable and focused on documentation needs.
"""

import argparse
import json
import os
import subprocess
import sys
from typing import Any, Dict, List, Tuple


def check_graphviz_installation() -> bool:
    """Check if Graphviz is installed and available.

    Returns:
        True if graphviz dot command is available, False otherwise
    """
    try:
        result = subprocess.run(
            ["dot", "-V"], capture_output=True, text=True, timeout=5
        )
        return result.returncode == 0
    except (FileNotFoundError, subprocess.TimeoutExpired):
        return False


def load_operations_json(json_path: str) -> Dict[str, Any]:
    """Load operations from JSON file.

    Args:
        json_path: Path to operations JSON file

    Returns:
        Operations data dictionary
    """
    with open(json_path, "r") as f:
        return json.load(f)


def create_conceptual_qdq_diagram(ops_data: Dict[str, Any]) -> str:
    """Create DOT format conceptual diagram showing QDQ architecture.

    Args:
        ops_data: Operations data from load_operations_json

    Returns:
        DOT format string
    """
    # Extract QDQ operations
    quantize_ops = [
        op for op in ops_data["operations"] if op["op_type"] == "QuantizeLinear"
    ]
    dequantize_ops = [
        op for op in ops_data["operations"] if op["op_type"] == "DequantizeLinear"
    ]

    # Build DOT graph showing conceptual flow
    dot_lines = [
        "digraph ResNet8_QDQ_Architecture {",
        '  rankdir="TB";',
        '  node [shape=box, style=filled, fontname="Arial", fontsize=10];',
        '  edge [fontname="Arial", fontsize=9];',
        "",
        "  // Input",
        '  input [label="Model Input\\n(batch, 32, 32, 3)\\n[FP32]", fillcolor="#E0F0FF"];',
        "",
    ]

    # Group operations by layer/block
    # For ResNet8: conv1 -> block1 -> block2 -> block3 -> pool -> dense

    # Add input quantization
    input_quant = [op for op in quantize_ops if "input" in op["name"].lower() or op == quantize_ops[0]]
    if input_quant:
        op = input_quant[0]
        scale_str = ""
        zp_str = ""
        for scale_name, scale_val in op["scales"].items():
            scale_str = f"\\nscale={scale_val:.6f}"
        for zp_name, zp_val in op["zero_points"].items():
            zp_str = f"\\nzp={zp_val}"

        dot_lines.append('  // Input Quantization')
        dot_lines.append(f'  q_input [label="QuantizeLinear{scale_str}{zp_str}\\n[FP32 → INT8]", fillcolor="#90EE90"];')
        dot_lines.append('  input -> q_input [label="FP32"];')
        dot_lines.append('')

    # Create layered representation
    dot_lines.extend([
        '  // QDQ Pattern Blocks',
        '  subgraph cluster_legend {',
        '    label="QDQ Format Pattern";',
        '    style=filled;',
        '    fillcolor="#F0F0F0";',
        '    pattern_q [label="QuantizeLinear\\n(FP32 → INT8)", fillcolor="#90EE90"];',
        '    pattern_dq [label="DequantizeLinear\\n(INT8 → FP32)", fillcolor="#FFB6C1"];',
        '    pattern_op [label="Operation\\n(Conv, Add, etc.)\\n[Operates on FP32]", fillcolor="#87CEEB"];',
        '    pattern_q -> pattern_dq [label="INT8"];',
        '    pattern_dq -> pattern_op [label="FP32"];',
        '  }',
        '',
    ])

    # Add summary statistics
    dot_lines.extend([
        '  // Architecture Summary',
        '  subgraph cluster_stats {',
        '    label="ResNet8 QDQ Statistics";',
        '    style=filled;',
        '    fillcolor="#FFF8DC";',
        f'    stats [shape=plaintext, label=<',
        f'      <table border="0" cellborder="1" cellspacing="0">',
        f'        <tr><td><b>Operation</b></td><td><b>Count</b></td></tr>',
        f'        <tr><td>QuantizeLinear</td><td>{len(quantize_ops)}</td></tr>',
        f'        <tr><td>DequantizeLinear</td><td>{len(dequantize_ops)}</td></tr>',
        f'        <tr><td>Total QDQ nodes</td><td>{len(quantize_ops) + len(dequantize_ops)}</td></tr>',
        f'        <tr><td>Total graph nodes</td><td>{ops_data["summary"]["total_nodes"]}</td></tr>',
        f'      </table>',
        f'    >];',
        '  }',
        '',
    ])

    # Add flow representation showing typical Q-DQ-Op pattern
    dot_lines.extend([
        '  // Typical Data Flow (simplified)',
        '  q_input -> layer1_dq [label="INT8"];',
        '  layer1_dq [label="DequantizeLinear\\n[INT8 → FP32]", fillcolor="#FFB6C1"];',
        '  layer1_dq -> layer1_conv [label="FP32"];',
        '  layer1_conv [label="Conv2D\\n[FP32 compute]", fillcolor="#87CEEB"];',
        '  layer1_conv -> layer1_q [label="FP32"];',
        '  layer1_q [label="QuantizeLinear\\n[FP32 → INT8]", fillcolor="#90EE90"];',
        '',
        '  layer1_q -> layer2_dq [label="INT8"];',
        '  layer2_dq [label="DequantizeLinear\\n[INT8 → FP32]", fillcolor="#FFB6C1"];',
        '  layer2_dq -> layer2_op [label="FP32"];',
        '  layer2_op [label="...\\n(more layers)\\n[FP32]", fillcolor="#87CEEB"];',
        '',
        '  layer2_op -> output_q [label="FP32"];',
        '  output_q [label="QuantizeLinear\\n[FP32 → INT8]", fillcolor="#90EE90"];',
        '  output_q -> output_dq [label="INT8"];',
        '  output_dq [label="DequantizeLinear\\n(final)\\n[INT8 → FP32]", fillcolor="#FFB6C1"];',
        '  output_dq -> output [label="FP32"];',
        '',
        '  // Output',
        '  output [label="Model Output\\n(batch, 10)\\n[FP32]", fillcolor="#FFE0E0"];',
        '',
    ])

    # Add notes about scale/zero-point storage
    dot_lines.extend([
        '  // Parameter Storage Note',
        '  note [shape=note, fillcolor="#FFFACD", ',
        '        label="Scale and Zero-Point Parameters\\n\\n',
        'Stored as initializers in ONNX graph.\\n',
        'Each Q/DQ node references 2-3 inputs:\\n',
        '  1. Data tensor (from previous layer)\\n',
        '  2. scale (FP32 initializer)\\n',
        '  3. zero_point (INT8 initializer, optional)\\n\\n',
        'Example from this model:\\n',
        f'  QuantizeLinear nodes: {len(quantize_ops)}\\n',
        f'  DequantizeLinear nodes: {len(dequantize_ops)}"];',
        '',
    ])

    dot_lines.append("}")
    return "\n".join(dot_lines)


def create_detailed_table(ops_data: Dict[str, Any]) -> str:
    """Create DOT format detailed table of all QDQ nodes.

    Args:
        ops_data: Operations data

    Returns:
        DOT format string for detailed table diagram
    """
    quantize_ops = [
        op for op in ops_data["operations"] if op["op_type"] == "QuantizeLinear"
    ]
    dequantize_ops = [
        op for op in ops_data["operations"] if op["op_type"] == "DequantizeLinear"
    ]

    dot_lines = [
        "digraph ResNet8_QDQ_Details {",
        '  rankdir="TB";',
        '  node [shape=plaintext];',
        '',
        '  quantize_table [label=<',
        '    <table border="1" cellborder="1" cellspacing="0">',
        '      <tr><td colspan="4"><b>QuantizeLinear Nodes</b></td></tr>',
        '      <tr><td><b>Node Name</b></td><td><b>Scale</b></td><td><b>Zero Point</b></td><td><b>Output</b></td></tr>',
    ]

    # Add first 10 quantize operations as examples
    for i, op in enumerate(quantize_ops[:10]):
        name = op["name"].replace("_", " ")
        scale_val = next(iter(op["scales"].values())) if op["scales"] else "N/A"
        zp_val = next(iter(op["zero_points"].values())) if op["zero_points"] else 0
        output = op["outputs"][0] if op["outputs"] else "N/A"

        if isinstance(scale_val, float):
            scale_str = f"{scale_val:.6f}"
        else:
            scale_str = str(scale_val)

        dot_lines.append(
            f'      <tr><td>{name}</td><td>{scale_str}</td><td>{zp_val}</td><td>{output[:30]}...</td></tr>'
        )

    if len(quantize_ops) > 10:
        dot_lines.append(f'      <tr><td colspan="4">... and {len(quantize_ops) - 10} more</td></tr>')

    dot_lines.extend([
        '    </table>',
        '  >];',
        '',
        '  dequantize_table [label=<',
        '    <table border="1" cellborder="1" cellspacing="0">',
        '      <tr><td colspan="4"><b>DequantizeLinear Nodes</b></td></tr>',
        '      <tr><td><b>Node Name</b></td><td><b>Scale</b></td><td><b>Zero Point</b></td><td><b>Input</b></td></tr>',
    ])

    # Add first 10 dequantize operations as examples
    for i, op in enumerate(dequantize_ops[:10]):
        name = op["name"].replace("_", " ")
        scale_val = next(iter(op["scales"].values())) if op["scales"] else "N/A"
        zp_val = next(iter(op["zero_points"].values())) if op["zero_points"] else 0
        input_tensor = op["inputs"][0] if op["inputs"] else "N/A"

        if isinstance(scale_val, float):
            scale_str = f"{scale_val:.6f}"
        else:
            scale_str = str(scale_val)

        dot_lines.append(
            f'      <tr><td>{name}</td><td>{scale_str}</td><td>{zp_val}</td><td>{input_tensor[:30]}...</td></tr>'
        )

    if len(dequantize_ops) > 10:
        dot_lines.append(f'      <tr><td colspan="4">... and {len(dequantize_ops) - 10} more</td></tr>')

    dot_lines.extend([
        '    </table>',
        '  >];',
        '}',
    ])

    return "\n".join(dot_lines)


def generate_diagrams(operations_json: str, output_dir: str) -> Tuple[str, str]:
    """Generate QDQ architecture diagrams.

    Args:
        operations_json: Path to operations JSON file
        output_dir: Output directory for visualization files

    Returns:
        Tuple of (png_path, svg_path)
    """
    # Load operations data
    print(f"Loading operations from: {operations_json}")
    ops_data = load_operations_json(operations_json)

    print(f"Found {ops_data['summary']['qlinear_nodes']} QDQ nodes")
    print(f"  QuantizeLinear: {ops_data['summary']['op_type_counts']['QuantizeLinear']}")
    print(f"  DequantizeLinear: {ops_data['summary']['op_type_counts']['DequantizeLinear']}")
    print()

    # Create output directory if needed
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Generate conceptual diagram
    print("Generating conceptual QDQ architecture diagram...")
    dot_content = create_conceptual_qdq_diagram(ops_data)

    # Write DOT file
    dot_path = os.path.join(output_dir, "resnet8_qdq_architecture.dot")
    print(f"Writing DOT file: {dot_path}")
    with open(dot_path, "w") as f:
        f.write(dot_content)

    # Generate PNG
    png_path = os.path.join(output_dir, "resnet8_qdq_architecture.png")
    print(f"Generating PNG: {png_path}")
    subprocess.run(
        ["dot", "-Tpng", dot_path, "-o", png_path],
        check=True,
        capture_output=True,
    )

    # Generate SVG
    svg_path = os.path.join(output_dir, "resnet8_qdq_architecture.svg")
    print(f"Generating SVG: {svg_path}")
    subprocess.run(
        ["dot", "-Tsvg", dot_path, "-o", svg_path],
        check=True,
        capture_output=True,
    )

    return png_path, svg_path


def main():
    parser = argparse.ArgumentParser(
        description="Generate annotated QDQ architecture diagrams from operation JSON"
    )
    parser.add_argument(
        "--model",
        help="Path to ONNX model file (for compatibility, not used)",
    )
    parser.add_argument(
        "--operations-json",
        default="models/resnet8_int8_operations.json",
        help="Path to operations JSON file (default: models/resnet8_int8_operations.json)",
    )
    parser.add_argument(
        "--output-dir",
        default="docs/images/",
        help="Output directory for visualization files (default: docs/images/)",
    )
    args = parser.parse_args()

    # Check for operations JSON
    json_path = args.operations_json
    if not os.path.exists(json_path):
        print(f"Error: Operations JSON not found: {json_path}", file=sys.stderr)
        print("Generate it with: python scripts/extract_operations.py", file=sys.stderr)
        sys.exit(1)

    # Check for graphviz installation
    if not check_graphviz_installation():
        print("Error: Graphviz not installed.", file=sys.stderr)
        print("Install with:", file=sys.stderr)
        print("  Ubuntu/Debian: sudo apt-get install graphviz", file=sys.stderr)
        print("  macOS: brew install graphviz", file=sys.stderr)
        sys.exit(1)

    # Generate diagrams
    png_path, svg_path = generate_diagrams(json_path, args.output_dir)

    # Print summary
    print()
    print("=" * 60)
    print("QDQ ARCHITECTURE VISUALIZATION COMPLETE")
    print("=" * 60)
    print(f"PNG file:  {png_path}")
    print(f"SVG file:  {svg_path}")
    print("=" * 60)
    print()
    print("The visualization shows:")
    print("  • QDQ format pattern (Q-DQ-Op repeated throughout network)")
    print("  • QuantizeLinear nodes (FP32 → INT8) in green")
    print("  • DequantizeLinear nodes (INT8 → FP32) in pink")
    print("  • Operations process FP32 data (not INT8)")
    print("  • Statistics: 32 QuantizeLinear + 66 DequantizeLinear nodes")
    print("  • Scale/zero-point parameters stored as initializers")


if __name__ == "__main__":
    main()
